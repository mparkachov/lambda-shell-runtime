#!/bin/sh
set -u

log() {
  printf '%s\n' "$*" >&2
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

make_temp_file() {
  if command_exists mktemp; then
    mktemp
    return $?
  fi
  base=${TMPDIR:-/tmp}/lambda-runtime
  i=0
  while [ "$i" -lt 100 ]; do
    candidate="${base}-$$-$i"
    if [ ! -e "$candidate" ]; then
      : > "$candidate" || return 1
      printf '%s' "$candidate"
      return 0
    fi
    i=$((i + 1))
  done
  return 1
}

json_escape() {
  printf '%s' "$1" | tr -d '\r' | sed 's/\\/\\\\/g; s/"/\\"/g'
}

header_value() {
  headers_file=$1
  header_name=$2
  awk -F': ' -v target="$(printf '%s' "$header_name" | tr '[:upper:]' '[:lower:]')" \
    'tolower($1)==target {print $2; exit}' "$headers_file" | tr -d '\r'
}

set_invocation_env() {
  name=$1
  value=$2
  if [ -n "$value" ]; then
    export "$name=$value"
  else
    unset "$name"
  fi
}

json_stacktrace_from_file() {
  file=$1
  skip_lines=${2:-0}
  count=0
  printf '['
  while IFS= read -r line; do
    if [ "$skip_lines" -gt 0 ]; then
      skip_lines=$((skip_lines - 1))
      continue
    fi
    escaped=$(json_escape "$line")
    if [ "$count" -gt 0 ]; then
      printf ','
    fi
    printf '"%s"' "$escaped"
    count=$((count + 1))
  done < "$file"
  printf ']'
}

build_error_payload() {
  message=$1
  error_type=$2
  stack_trace=$3
  escaped_message=$(json_escape "$message")
  escaped_type=$(json_escape "$error_type")
  printf '{"errorMessage":"%s","errorType":"%s","stackTrace":%s}' \
    "$escaped_message" "$escaped_type" "$stack_trace"
}

build_init_error_payload() {
  message=$1
  error_type=$2
  printf '{"errorMessage":"%s","errorType":"%s","stackTrace":[]}' \
    "$message" "$error_type"
}

post_runtime_error() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    -H "Lambda-Runtime-Function-Error-Type: Unhandled" \
    --data-binary "@$payload" "$url")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    http_code=000
  fi
  case "$http_code" in
    2??) return 0 ;;
    *)
      log "Failed to post runtime error to $url (HTTP $http_code)"
      return 1
      ;;
  esac
}

post_runtime_response() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    --data-binary "@$payload" "$url")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    http_code=000
  fi
  case "$http_code" in
    2??) return 0 ;;
    *)
      log "Failed to post runtime response to $url (HTTP $http_code)"
      return 1
      ;;
  esac
}

post_streaming_response() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    -H "Lambda-Runtime-Function-Response-Mode: streaming" \
    -H "Trailer: Lambda-Runtime-Function-Error-Type, Lambda-Runtime-Function-Error-Body" \
    -H "Expect:" \
    --data-binary @- "$url" < "$payload")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    http_code=000
  fi
  case "$http_code" in
    2??) return 0 ;;
    *)
      log "Failed to post runtime streaming response to $url (HTTP $http_code)"
      return 1
      ;;
  esac
}

post_init_error() {
  message=$1
  error_type=$2
  payload_mode=${3:-escaped}
  payload=$(make_temp_file) || {
    log "Failed to create init error payload"
    return 1
  }
  if [ "$payload_mode" = "raw" ]; then
    build_init_error_payload "$message" "$error_type" > "$payload"
  else
    build_error_payload "$message" "$error_type" "[]" > "$payload"
  fi
  if ! post_runtime_error \
    "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" \
    "$payload"; then
    rm -f "$payload"
    return 1
  fi
  rm -f "$payload"
  return 0
}

post_invoke_error() {
  request_id=$1
  message=$2
  error_type=$3
  stack_trace=$4
  payload=$(mktemp)
  build_error_payload "$message" "$error_type" "$stack_trace" > "$payload"
  if ! post_runtime_error \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/error" \
    "$payload"; then
    rm -f "$payload"
    return 1
  fi
  rm -f "$payload"
  return 0
}

post_response() {
  request_id=$1
  response_file=$2
  post_runtime_response \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/response" \
    "$response_file"
}

stream_response() {
  request_id=$1
  stderr_file=$2
  shift 2

  response_pipe=$(make_temp_file) || {
    log "Failed to create response pipe"
    return 1
  }
  rm -f "$response_pipe"
  if ! mkfifo "$response_pipe"; then
    log "Failed to create response pipe"
    return 1
  fi

  post_streaming_response \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/response" \
    "$response_pipe" &
  post_pid=$!

  if run_with_stderr_capture "$stderr_file" "$@" > "$response_pipe"; then
    handler_exit=0
  else
    handler_exit=$?
  fi

  if wait "$post_pid"; then
    post_status=0
  else
    post_status=$?
  fi

  rm -f "$response_pipe"

  if [ "$handler_exit" -eq 0 ]; then
    if [ "$post_status" -eq 0 ]; then
      return 0
    fi
    return 1
  fi

  log "Handler exited with status ${handler_exit}"
  set_error_from_stderr "$stderr_file" "$handler_exit"
  if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
    return 1
  fi
  return 0
}

# Capture handler stderr while streaming it to the runtime logs.
run_with_stderr_capture() {
  stderr_file=$1
  shift
  stderr_pipe=$(mktemp)
  rm -f "$stderr_pipe"
  mkfifo "$stderr_pipe"
  tee "$stderr_file" < "$stderr_pipe" >&2 &
  tee_pid=$!
  "$@" 2> "$stderr_pipe"
  status=$?
  wait "$tee_pid" >/dev/null 2>&1 || true
  rm -f "$stderr_pipe"
  return "$status"
}

set_error_from_stderr() {
  stderr_file=$1
  exit_status=$2
  error_message="Handler exited with status $exit_status"
  error_type="Error"
  stack_trace="[]"
  if [ -s "$stderr_file" ]; then
    IFS= read -r first_line < "$stderr_file" || true
    first_line=$(printf '%s' "$first_line" | tr -d '\r')
    if [ -n "$first_line" ]; then
      error_message="$first_line"
      error_type="Error"
      case "$first_line" in
        *:*)
          candidate_type=${first_line%%:*}
          candidate_message=${first_line#*:}
          candidate_message=$(printf '%s' "$candidate_message" | sed 's/^ *//')
          if [ -n "$candidate_type" ] && [ -n "$candidate_message" ]; then
            error_type="$candidate_type"
            error_message="$candidate_message"
          fi
          ;;
      esac
      stack_trace=$(json_stacktrace_from_file "$stderr_file" 1)
    fi
  fi
}

runtime_api=${AWS_LAMBDA_RUNTIME_API:-}
if [ -z "$runtime_api" ]; then
  log "AWS_LAMBDA_RUNTIME_API is not set"
  exit 1
fi

required_tools="curl awk sed tr mktemp mkfifo"
missing_tools=""
for tool in $required_tools; do
  if ! command_exists "$tool"; then
    if [ -n "$missing_tools" ]; then
      missing_tools="$missing_tools $tool"
    else
      missing_tools="$tool"
    fi
  fi
done

if [ -n "$missing_tools" ]; then
  message="Missing required host tools: $missing_tools"
  log "$message"
  if command_exists curl; then
    post_init_error "$message" "Runtime.InitError" "raw" || true
  fi
  exit 1
fi

task_root=${LAMBDA_TASK_ROOT:-/var/task}
handler_name=${_HANDLER:-}
if [ -z "$handler_name" ]; then
  post_init_error "Missing _HANDLER" "Runtime.InvalidHandler"
  exit 1
fi

handler_mode=""
handler_path=""
handler_func=""
handler_basename=${handler_name##*/}

case "$handler_basename" in
  *.*)
    handler_script=${handler_name%.*}
    handler_func=${handler_name##*.}
    if [ -z "$handler_script" ] || [ -z "$handler_func" ]; then
      post_init_error "Invalid _HANDLER: $handler_name" "Runtime.InvalidHandler"
      exit 1
    fi
    case "$handler_script" in
      /*) handler_path="$handler_script" ;;
      *) handler_path="$task_root/$handler_script" ;;
    esac
    case "$handler_path" in
      *.sh) ;;
      *) handler_path="${handler_path}.sh" ;;
    esac
    if [ ! -f "$handler_path" ]; then
      post_init_error "Handler script not found: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if [ ! -r "$handler_path" ]; then
      post_init_error "Handler script not readable: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if ! . "$handler_path"; then
      post_init_error "Failed to load handler script: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if ! command -v "$handler_func" >/dev/null 2>&1; then
      post_init_error "Handler function not found: $handler_func" "Runtime.InvalidHandler"
      exit 1
    fi
    handler_mode="function"
    ;;
  *)
    case "$handler_name" in
      /*) handler_path="$handler_name" ;;
      *) handler_path="$task_root/$handler_name" ;;
    esac
    if [ ! -f "$handler_path" ]; then
      post_init_error "Handler not found: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if [ ! -x "$handler_path" ]; then
      if [ ! -r "$handler_path" ]; then
        post_init_error "Handler not readable: $handler_path" "Runtime.InvalidHandler"
        exit 1
      fi
      handler_mode="script"
    else
      handler_mode="executable"
    fi
    ;;
esac

while :; do
  headers=$(mktemp)
  body=$(mktemp)

  if ! curl -sS -D "$headers" -o "$body" \
    "http://${runtime_api}/2018-06-01/runtime/invocation/next"; then
    log "Failed to fetch next invocation"
    rm -f "$headers" "$body"
    exit 1
  fi

  request_id=$(header_value "$headers" "Lambda-Runtime-Aws-Request-Id")
  if [ -z "$request_id" ]; then
    log "Missing Lambda-Runtime-Aws-Request-Id header"
    rm -f "$headers" "$body"
    exit 1
  fi
  deadline_ms=$(header_value "$headers" "Lambda-Runtime-Deadline-Ms")
  invoked_function_arn=$(header_value "$headers" "Lambda-Runtime-Invoked-Function-Arn")
  trace_id=$(header_value "$headers" "Lambda-Runtime-Trace-Id")
  client_context=$(header_value "$headers" "Lambda-Runtime-Client-Context")
  cognito_identity=$(header_value "$headers" "Lambda-Runtime-Cognito-Identity")
  response_mode=$(header_value "$headers" "Lambda-Runtime-Function-Response-Mode")

  set_invocation_env "LAMBDA_RUNTIME_AWS_REQUEST_ID" "$request_id"
  set_invocation_env "LAMBDA_RUNTIME_DEADLINE_MS" "$deadline_ms"
  set_invocation_env "LAMBDA_RUNTIME_INVOKED_FUNCTION_ARN" "$invoked_function_arn"
  set_invocation_env "LAMBDA_RUNTIME_TRACE_ID" "$trace_id"
  set_invocation_env "LAMBDA_RUNTIME_CLIENT_CONTEXT" "$client_context"
  set_invocation_env "LAMBDA_RUNTIME_COGNITO_IDENTITY" "$cognito_identity"
  set_invocation_env "_X_AMZN_TRACE_ID" "$trace_id"

  response=$(mktemp)
  stderr_file=$(mktemp)
  if [ "$handler_mode" = "function" ]; then
    event_data=$(cat "$body")
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" "$handler_func" "$event_data"; then
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
    else
      if run_with_stderr_capture "$stderr_file" "$handler_func" "$event_data" > "$response"; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  elif [ "$handler_mode" = "executable" ]; then
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" "$handler_path" < "$body"; then
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
    else
      if run_with_stderr_capture "$stderr_file" "$handler_path" < "$body" > "$response"; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  else
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" sh "$handler_path" < "$body"; then
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
    else
      if run_with_stderr_capture "$stderr_file" sh "$handler_path" < "$body" > "$response"; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  fi

  rm -f "$headers" "$body" "$response" "$stderr_file"
done
