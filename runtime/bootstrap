#!/bin/sh
set -u

log() {
  printf '%s\n' "$*" >&2
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

restore_runtime_after_handler=0
runtime_errexit=0
runtime_nounset=0
runtime_ifs=
runtime_ifs_set=1
xray_enabled=0
xray_trace_root=
xray_trace_parent=
xray_trace_sampled=
xray_segment_id=
xray_segment_start_ms=
xray_segment_end_ms=
stream_handler_status=0

capture_runtime_state() {
  runtime_ifs_set=0
  if [ "${IFS+x}" = "x" ]; then
    runtime_ifs_set=1
    runtime_ifs=$IFS
  fi
  runtime_errexit=0
  case $- in
    *e*) runtime_errexit=1 ;;
  esac
  runtime_nounset=0
  case $- in
    *u*) runtime_nounset=1 ;;
  esac
}

restore_runtime_state() {
  if [ "$runtime_ifs_set" -eq 1 ]; then
    IFS=$runtime_ifs
  else
    unset IFS
  fi
  if [ "$runtime_errexit" -eq 1 ]; then
    set -e
  else
    set +e
  fi
  if [ "$runtime_nounset" -eq 1 ]; then
    set -u
  else
    set +u
  fi
}

make_temp_file() {
  if command_exists mktemp; then
    mktemp
    return $?
  fi
  base=${TMPDIR:-/tmp}/lambda-runtime
  i=0
  while [ "$i" -lt 100 ]; do
    candidate="${base}-$$-$i"
    if [ ! -e "$candidate" ]; then
      : > "$candidate" || return 1
      printf '%s' "$candidate"
      return 0
    fi
    i=$((i + 1))
  done
  return 1
}

json_escape() {
  printf '%s' "$1" | od -An -tu1 -v | awk '
    BEGIN { ORS=""; }
    {
      for (i = 1; i <= NF; i++) {
        b = $i + 0
        if (b == 34) {
          printf "\\\""
        } else if (b == 92) {
          printf "\\\\"
        } else if (b == 8) {
          printf "\\b"
        } else if (b == 12) {
          printf "\\f"
        } else if (b == 10) {
          printf "\\n"
        } else if (b == 13) {
          printf "\\r"
        } else if (b == 9) {
          printf "\\t"
        } else if (b < 32) {
          printf "\\u%04x", b
        } else {
          printf "%c", b
        }
      }
    }
  '
}

header_value() {
  headers_file=$1
  header_name=$2
  awk -F': ' -v target="$(printf '%s' "$header_name" | tr '[:upper:]' '[:lower:]')" \
    'tolower($1)==target {print $2; exit}' "$headers_file" | tr -d '\r'
}

reset_xray_state() {
  xray_enabled=0
  xray_trace_root=
  xray_trace_parent=
  xray_trace_sampled=
  xray_segment_id=
  xray_segment_start_ms=
  xray_segment_end_ms=
}

parse_xray_trace_header() {
  header=$1
  if [ -z "$header" ]; then
    return 0
  fi
  old_ifs=$IFS
  IFS=';'
  set -- $header
  IFS=$old_ifs
  for part in "$@"; do
    case "$part" in
      Root=*) xray_trace_root=${part#Root=} ;;
      Parent=*) xray_trace_parent=${part#Parent=} ;;
      Sampled=*) xray_trace_sampled=${part#Sampled=} ;;
    esac
  done
  if [ -n "$xray_trace_root" ] && [ "$xray_trace_sampled" = "1" ] && \
    [ -n "${AWS_XRAY_DAEMON_ADDRESS:-}" ]; then
    xray_enabled=1
  fi
}

xray_now_ms() {
  if ! command_exists date; then
    return 1
  fi
  now_ms=$(date +%s%3N 2>/dev/null || true)
  case "$now_ms" in
    ''|*[!0-9]*)
      now_ms=$(date +%s 2>/dev/null || true)
      case "$now_ms" in
        ''|*[!0-9]*) return 1 ;;
      esac
      now_ms=$((now_ms * 1000))
      ;;
  esac
  printf '%s' "$now_ms"
}

xray_format_time() {
  ms=$1
  case "$ms" in
    ''|*[!0-9]*) return 1 ;;
  esac
  sec=$((ms / 1000))
  msec=$((ms % 1000))
  printf '%s.%03d' "$sec" "$msec"
}

xray_generate_segment_id() {
  segment_id=$(od -An -N8 -tx1 /dev/urandom 2>/dev/null | tr -d ' \n')
  if [ -n "$segment_id" ]; then
    printf '%s' "$segment_id"
    return 0
  fi
  fallback=
  if command_exists date; then
    fallback=$(date +%s 2>/dev/null || true)
  fi
  case "$fallback" in
    ''|*[!0-9]*) fallback=$$ ;;
  esac
  printf '%016x' "$fallback"
}

xray_start_segment() {
  if [ "$xray_enabled" -ne 1 ]; then
    return 0
  fi
  xray_segment_id=$(xray_generate_segment_id)
  xray_segment_start_ms=$(xray_now_ms 2>/dev/null || true)
  if [ -z "$xray_segment_start_ms" ]; then
    xray_enabled=0
    return 1
  fi
  return 0
}

xray_finish_segment() {
  if [ "$xray_enabled" -ne 1 ]; then
    return 0
  fi
  xray_segment_end_ms=$(xray_now_ms 2>/dev/null || true)
  if [ -z "$xray_segment_end_ms" ]; then
    xray_enabled=0
    return 1
  fi
  return 0
}

xray_log_segment() {
  handler_status=${1:-0}
  if [ "$xray_enabled" -ne 1 ]; then
    return 0
  fi
  if [ -z "$xray_segment_start_ms" ] || [ -z "$xray_segment_end_ms" ]; then
    return 0
  fi
  start_time=$(xray_format_time "$xray_segment_start_ms") || return 0
  end_time=$(xray_format_time "$xray_segment_end_ms") || return 0
  segment_id=$xray_segment_id
  if [ -z "$segment_id" ]; then
    segment_id=$(xray_generate_segment_id)
  fi
  name=${AWS_LAMBDA_FUNCTION_NAME:-}
  if [ -z "$name" ]; then
    name=${LAMBDA_RUNTIME_INVOKED_FUNCTION_ARN:-lambda}
  fi
  escaped_name=$(json_escape "$name")
  escaped_trace=$(json_escape "$xray_trace_root")
  escaped_segment_id=$(json_escape "$segment_id")
  segment=$(printf '{"trace_id":"%s","id":"%s","start_time":%s,"end_time":%s,"name":"%s"' \
    "$escaped_trace" "$escaped_segment_id" "$start_time" "$end_time" "$escaped_name")
  if [ -n "$xray_trace_parent" ]; then
    escaped_parent=$(json_escape "$xray_trace_parent")
    segment="${segment},\"parent_id\":\"${escaped_parent}\""
  fi
  if [ "$handler_status" -ne 0 ]; then
    segment="${segment},\"fault\":true"
  fi
  segment="${segment}}"
  log "X-Ray segment: $segment"
  return 0
}

log_runtime_api_body() {
  body_file=$1
  if [ -s "$body_file" ]; then
    body=$(tr -d '\r' < "$body_file" | tr '\n' ' ')
    if [ -n "$body" ]; then
      log "Runtime API response body: $body"
    fi
  fi
}

is_retryable_http_code() {
  case "$1" in
    429|500|502|503|504) return 0 ;;
    *) return 1 ;;
  esac
}

fetch_next_invocation() {
  headers_file=$1
  body_file=$2
  attempt=1
  delay=$next_retry_delay
  while :; do
    http_code=$(curl -sS -D "$headers_file" -o "$body_file" -w '%{http_code}' \
      "http://${runtime_api}/2018-06-01/runtime/invocation/next")
    curl_status=$?
    if [ "$curl_status" -eq 0 ] && [ "$http_code" = "$runtime_next_expected_code" ]; then
      return 0
    fi

    if [ "$curl_status" -ne 0 ]; then
      log "Failed to fetch next invocation (curl status $curl_status)"
      retryable=1
    else
      log "Unexpected response from Runtime API /next (HTTP $http_code, expected $runtime_next_expected_code)"
      log_runtime_api_body "$body_file"
      if is_retryable_http_code "$http_code"; then
        retryable=1
      else
        retryable=0
      fi
    fi

    if [ "$retryable" -eq 0 ] || [ "$attempt" -ge "$next_retry_max" ]; then
      return 1
    fi

    log "Retrying Runtime API /next in ${delay}s"
    sleep "$delay"
    if [ "$delay" -lt "$next_retry_max_delay" ]; then
      delay=$((delay * 2))
      if [ "$delay" -gt "$next_retry_max_delay" ]; then
        delay=$next_retry_max_delay
      fi
    fi
    attempt=$((attempt + 1))
  done
}

set_invocation_env() {
  name=$1
  value=$2
  if [ -n "$value" ]; then
    export "$name=$value"
  else
    unset "$name"
  fi
}

json_stacktrace_from_file() {
  file=$1
  skip_lines=${2:-0}
  count=0
  printf '['
  while IFS= read -r line; do
    if [ "$skip_lines" -gt 0 ]; then
      skip_lines=$((skip_lines - 1))
      continue
    fi
    escaped=$(json_escape "$line")
    if [ "$count" -gt 0 ]; then
      printf ','
    fi
    printf '"%s"' "$escaped"
    count=$((count + 1))
  done < "$file"
  printf ']'
}

build_error_payload() {
  message=$1
  error_type=$2
  stack_trace=$3
  escaped_message=$(json_escape "$message")
  escaped_type=$(json_escape "$error_type")
  printf '{"errorMessage":"%s","errorType":"%s","stackTrace":%s}' \
    "$escaped_message" "$escaped_type" "$stack_trace"
}

build_init_error_payload() {
  message=$1
  error_type=$2
  mode=${3:-escaped}
  if [ "$mode" = "raw" ]; then
    printf '{"errorMessage":"%s","errorType":"%s","stackTrace":[]}' \
      "$message" "$error_type"
    return 0
  fi
  escaped_message=$(json_escape "$message")
  escaped_type=$(json_escape "$error_type")
  printf '{"errorMessage":"%s","errorType":"%s","stackTrace":[]}' \
    "$escaped_message" "$escaped_type"
}

post_runtime_error() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    -H "Lambda-Runtime-Function-Error-Type: Unhandled" \
    --data-binary "@$payload" "$url")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    log "Failed to post runtime error to $url (curl status $curl_status)"
    return 1
  fi
  if [ "$http_code" != "$runtime_post_expected_code" ]; then
    log "Failed to post runtime error to $url (HTTP $http_code, expected $runtime_post_expected_code)"
    return 1
  fi
  return 0
}

post_runtime_response() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    --data-binary "@$payload" "$url")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    log "Failed to post runtime response to $url (curl status $curl_status)"
    return 1
  fi
  if [ "$http_code" != "$runtime_post_expected_code" ]; then
    log "Failed to post runtime response to $url (HTTP $http_code, expected $runtime_post_expected_code)"
    return 1
  fi
  return 0
}

post_streaming_response() {
  url=$1
  payload=$2
  http_code=$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
    -H "Lambda-Runtime-Function-Response-Mode: streaming" \
    -H "Trailer: Lambda-Runtime-Function-Error-Type, Lambda-Runtime-Function-Error-Body" \
    -H "Expect:" \
    --data-binary @- "$url" < "$payload")
  curl_status=$?
  if [ "$curl_status" -ne 0 ]; then
    log "Failed to post runtime streaming response to $url (curl status $curl_status)"
    return 1
  fi
  if [ "$http_code" != "$runtime_post_expected_code" ]; then
    log "Failed to post runtime streaming response to $url (HTTP $http_code, expected $runtime_post_expected_code)"
    return 1
  fi
  return 0
}

post_init_error() {
  message=$1
  error_type=$2
  payload_mode=${3:-escaped}
  payload=$(make_temp_file) || {
    log "Failed to create init error payload"
    return 1
  }
  if [ "$payload_mode" = "raw" ]; then
    build_init_error_payload "$message" "$error_type" "raw" > "$payload"
  else
    build_error_payload "$message" "$error_type" "[]" > "$payload"
  fi
  if ! post_runtime_error \
    "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" \
    "$payload"; then
    rm -f "$payload"
    return 1
  fi
  rm -f "$payload"
  return 0
}

post_invoke_error() {
  request_id=$1
  message=$2
  error_type=$3
  stack_trace=$4
  payload=$(mktemp)
  build_error_payload "$message" "$error_type" "$stack_trace" > "$payload"
  if ! post_runtime_error \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/error" \
    "$payload"; then
    rm -f "$payload"
    return 1
  fi
  rm -f "$payload"
  return 0
}

post_response() {
  request_id=$1
  response_file=$2
  post_runtime_response \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/response" \
    "$response_file"
}

stream_response() {
  request_id=$1
  stderr_file=$2
  shift 2

  stream_handler_status=0
  response_pipe=$(make_temp_file) || {
    log "Failed to create response pipe"
    stream_handler_status=1
    return 1
  }
  rm -f "$response_pipe"
  if ! mkfifo "$response_pipe"; then
    log "Failed to create response pipe"
    stream_handler_status=1
    return 1
  fi

  post_streaming_response \
    "http://${runtime_api}/2018-06-01/runtime/invocation/${request_id}/response" \
    "$response_pipe" &
  post_pid=$!

  if run_with_stderr_capture "$stderr_file" "$@" > "$response_pipe"; then
    handler_exit=0
  else
    handler_exit=$?
  fi
  stream_handler_status=$handler_exit

  if wait "$post_pid"; then
    post_status=0
  else
    post_status=$?
  fi

  rm -f "$response_pipe"

  if [ "$handler_exit" -eq 0 ]; then
    if [ "$post_status" -eq 0 ]; then
      return 0
    fi
    return 1
  fi

  log "Handler exited with status ${handler_exit}"
  set_error_from_stderr "$stderr_file" "$handler_exit"
  if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
    return 1
  fi
  return 0
}

# Capture handler stderr while streaming it to the runtime logs.
run_with_stderr_capture() {
  stderr_file=$1
  shift
  stderr_pipe=$(mktemp)
  rm -f "$stderr_pipe"
  mkfifo "$stderr_pipe"
  tee "$stderr_file" < "$stderr_pipe" >&2 &
  tee_pid=$!
  "$@" 2> "$stderr_pipe"
  status=$?
  if [ "$restore_runtime_after_handler" -eq 1 ]; then
    restore_runtime_state
  fi
  wait "$tee_pid" >/dev/null 2>&1 || true
  rm -f "$stderr_pipe"
  return "$status"
}

set_error_from_stderr() {
  stderr_file=$1
  exit_status=$2
  error_message="Handler exited with status $exit_status"
  error_type="Error"
  stack_trace="[]"
  if [ -s "$stderr_file" ]; then
    IFS= read -r first_line < "$stderr_file" || true
    first_line=$(printf '%s' "$first_line" | tr -d '\r')
    if [ -n "$first_line" ]; then
      error_message="$first_line"
      error_type="Error"
      case "$first_line" in
        *:*)
          candidate_type=${first_line%%:*}
          candidate_message=${first_line#*:}
          candidate_message=$(printf '%s' "$candidate_message" | sed 's/^ *//')
          if [ -n "$candidate_type" ] && [ -n "$candidate_message" ]; then
            error_type="$candidate_type"
            error_message="$candidate_message"
          fi
          ;;
      esac
      stack_trace=$(json_stacktrace_from_file "$stderr_file" 1)
    fi
  fi
}

runtime_next_expected_code=200
runtime_post_expected_code=202
next_retry_max=3
next_retry_delay=1
next_retry_max_delay=4

runtime_api=${AWS_LAMBDA_RUNTIME_API:-}
if [ -z "$runtime_api" ]; then
  log "AWS_LAMBDA_RUNTIME_API is not set"
  exit 1
fi

required_tools="curl awk sed tr od mktemp mkfifo sleep"
missing_tools=""
for tool in $required_tools; do
  if ! command_exists "$tool"; then
    if [ -n "$missing_tools" ]; then
      missing_tools="$missing_tools $tool"
    else
      missing_tools="$tool"
    fi
  fi
done

if [ -n "$missing_tools" ]; then
  message="Missing required host tools: $missing_tools"
  log "$message"
  if command_exists curl; then
    post_init_error "$message" "Runtime.InitError" "raw" || true
  fi
  exit 1
fi

task_root=${LAMBDA_TASK_ROOT:-/var/task}
handler_name=${_HANDLER:-}
if [ -z "$handler_name" ]; then
  post_init_error "Missing _HANDLER" "Runtime.InvalidHandler"
  exit 1
fi

handler_mode=""
handler_path=""
handler_func=""
handler_basename=${handler_name##*/}

case "$handler_basename" in
  *.*)
    handler_script=${handler_name%.*}
    handler_func=${handler_name##*.}
    if [ -z "$handler_script" ] || [ -z "$handler_func" ]; then
      post_init_error "Invalid _HANDLER: $handler_name" "Runtime.InvalidHandler"
      exit 1
    fi
    case "$handler_script" in
      /*) handler_path="$handler_script" ;;
      *) handler_path="$task_root/$handler_script" ;;
    esac
    case "$handler_path" in
      *.sh) ;;
      *) handler_path="${handler_path}.sh" ;;
    esac
    if [ ! -f "$handler_path" ]; then
      post_init_error "Handler script not found: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if [ ! -r "$handler_path" ]; then
      post_init_error "Handler script not readable: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    capture_runtime_state
    if ! . "$handler_path"; then
      post_init_error "Failed to load handler script: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if ! command -v "$handler_func" >/dev/null 2>&1; then
      post_init_error "Handler function not found: $handler_func" "Runtime.InvalidHandler"
      exit 1
    fi
    restore_runtime_state
    restore_runtime_after_handler=1
    handler_mode="function"
    ;;
  *)
    case "$handler_name" in
      /*) handler_path="$handler_name" ;;
      *) handler_path="$task_root/$handler_name" ;;
    esac
    if [ ! -f "$handler_path" ]; then
      post_init_error "Handler not found: $handler_path" "Runtime.InvalidHandler"
      exit 1
    fi
    if [ ! -x "$handler_path" ]; then
      if [ ! -r "$handler_path" ]; then
        post_init_error "Handler not readable: $handler_path" "Runtime.InvalidHandler"
        exit 1
      fi
      handler_mode="script"
    else
      handler_mode="executable"
    fi
    ;;
esac

while :; do
  headers=$(mktemp)
  body=$(mktemp)

  if ! fetch_next_invocation "$headers" "$body"; then
    rm -f "$headers" "$body"
    exit 1
  fi

  request_id=$(header_value "$headers" "Lambda-Runtime-Aws-Request-Id")
  if [ -z "$request_id" ]; then
    log "Missing Lambda-Runtime-Aws-Request-Id header"
    rm -f "$headers" "$body"
    exit 1
  fi
  deadline_ms=$(header_value "$headers" "Lambda-Runtime-Deadline-Ms")
  invoked_function_arn=$(header_value "$headers" "Lambda-Runtime-Invoked-Function-Arn")
  trace_id=$(header_value "$headers" "Lambda-Runtime-Trace-Id")
  client_context=$(header_value "$headers" "Lambda-Runtime-Client-Context")
  cognito_identity=$(header_value "$headers" "Lambda-Runtime-Cognito-Identity")
  response_mode=$(header_value "$headers" "Lambda-Runtime-Function-Response-Mode")

  set_invocation_env "LAMBDA_RUNTIME_AWS_REQUEST_ID" "$request_id"
  set_invocation_env "LAMBDA_RUNTIME_DEADLINE_MS" "$deadline_ms"
  set_invocation_env "LAMBDA_RUNTIME_INVOKED_FUNCTION_ARN" "$invoked_function_arn"
  set_invocation_env "LAMBDA_RUNTIME_TRACE_ID" "$trace_id"
  set_invocation_env "LAMBDA_RUNTIME_CLIENT_CONTEXT" "$client_context"
  set_invocation_env "LAMBDA_RUNTIME_COGNITO_IDENTITY" "$cognito_identity"
  set_invocation_env "_X_AMZN_TRACE_ID" "$trace_id"

  reset_xray_state
  parse_xray_trace_header "$trace_id"

  response=$(mktemp)
  stderr_file=$(mktemp)
  xray_start_segment
  if [ "$handler_mode" = "function" ]; then
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" "$handler_func" < "$body"; then
        handler_exit=$stream_handler_status
        xray_finish_segment
        xray_log_segment "$handler_exit"
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
      handler_exit=$stream_handler_status
      xray_finish_segment
      xray_log_segment "$handler_exit"
    else
      if run_with_stderr_capture "$stderr_file" "$handler_func" < "$body" > "$response"; then
        handler_exit=0
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
      fi
      xray_finish_segment
      xray_log_segment "$handler_exit"
      if [ "$handler_exit" -eq 0 ]; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  elif [ "$handler_mode" = "executable" ]; then
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" "$handler_path" < "$body"; then
        handler_exit=$stream_handler_status
        xray_finish_segment
        xray_log_segment "$handler_exit"
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
      handler_exit=$stream_handler_status
      xray_finish_segment
      xray_log_segment "$handler_exit"
    else
      if run_with_stderr_capture "$stderr_file" "$handler_path" < "$body" > "$response"; then
        handler_exit=0
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
      fi
      xray_finish_segment
      xray_log_segment "$handler_exit"
      if [ "$handler_exit" -eq 0 ]; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  else
    if [ "$response_mode" = "streaming" ]; then
      if ! stream_response "$request_id" "$stderr_file" sh "$handler_path" < "$body"; then
        handler_exit=$stream_handler_status
        xray_finish_segment
        xray_log_segment "$handler_exit"
        rm -f "$headers" "$body" "$response" "$stderr_file"
        exit 1
      fi
      handler_exit=$stream_handler_status
      xray_finish_segment
      xray_log_segment "$handler_exit"
    else
      if run_with_stderr_capture "$stderr_file" sh "$handler_path" < "$body" > "$response"; then
        handler_exit=0
      else
        handler_exit=$?
        log "Handler exited with status ${handler_exit}"
        set_error_from_stderr "$stderr_file" "$handler_exit"
      fi
      xray_finish_segment
      xray_log_segment "$handler_exit"
      if [ "$handler_exit" -eq 0 ]; then
        if ! post_response "$request_id" "$response"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      else
        if ! post_invoke_error "$request_id" "$error_message" "$error_type" "$stack_trace"; then
          rm -f "$headers" "$body" "$response" "$stderr_file"
          exit 1
        fi
      fi
    fi
  fi

  rm -f "$headers" "$body" "$response" "$stderr_file"
done
